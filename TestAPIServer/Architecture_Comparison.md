# 아키텍처 비교: 직접 연결 vs API 서버

## 1. 이전 방식: Client <-> KepServer (직접 OPC UA 연결)

### 장점 ✅

1. **성능**
   - 직접 연결로 지연시간 최소
   - 중간 계층 없어 오버헤드 없음
   - 실시간 데이터 처리에 최적

2. **단순성**
   - 클라이언트가 직접 OPC UA 라이브러리 사용
   - 추가 서버 구성 불필요
   - 디버깅이 상대적으로 쉬움

3. **리소스 효율성**
   - API 서버 리소스 불필요
   - 네트워크 홉(hop) 최소화

4. **독립성**
   - 각 클라이언트가 독립적으로 연결
   - 한 클라이언트 문제가 다른 클라이언트에 영향 없음

### 단점 ❌

1. **확장성 문제**
   - 클라이언트 수 증가 시 KepServer 부하 증가
   - 각 클라이언트마다 연결 필요 (예: 10개 클라이언트 = 10개 연결)

2. **중앙 관리 어려움**
   - 연결 상태 모니터링 어려움
   - 로깅/감사 추적 분산
   - 보안 정책 일괄 적용 어려움

3. **클라이언트 제약**
   - OPC UA 라이브러리 설치 필요
   - .NET 환경에 종속 (WinForm만 가능)
   - 웹 클라이언트(Blazor) 직접 연결 어려움

4. **유지보수**
   - 각 클라이언트에 OPC UA 설정 필요
   - KepServer IP 변경 시 모든 클라이언트 수정
   - 버전 업그레이드 시 모든 클라이언트 업데이트

5. **네트워크 보안**
   - 각 클라이언트가 KepServer 네트워크 접근 필요
   - 방화벽 규칙 복잡
   - 보안 취약점 확산

---

## 2. 현재 방식: Client <-> API Server <-> KepServer

### 장점 ✅

1. **확장성**
   - API 서버 하나로 여러 클라이언트 지원
   - KepServer 연결 수 최소화 (1개 연결로 모든 클라이언트 서비스)
   - 수평 확장 가능 (로드 밸런싱)

2. **중앙 관리**
   - 연결 상태 중앙 모니터링
   - 통합 로깅 및 감사 추적
   - 보안 정책 일괄 적용

3. **클라이언트 다양성**
   - WinForm, Blazor, 모바일 등 다양한 클라이언트 지원
   - OPC UA 라이브러리 불필요 (HTTP만 사용)
   - 어떤 언어로도 클라이언트 개발 가능

4. **유지보수 용이**
   - KepServer 설정 변경 시 API 서버만 수정
   - 클라이언트 코드 변경 최소화
   - 버전 관리 단순화

5. **네트워크 보안**
   - KepServer는 API 서버에만 노출
   - 클라이언트는 API 서버만 접근
   - 방화벽 규칙 단순화

6. **추가 기능**
   - 데이터 캐싱 가능
   - 요청 제한(Rate Limiting)
   - 인증/인가 추가 용이
   - 데이터 변환/가공 중간 처리

### 단점 ❌

1. **성능 오버헤드**
   - 중간 계층으로 인한 약간의 지연
   - HTTP 프로토콜 오버헤드
   - API 서버 리소스 필요

2. **복잡성 증가**
   - API 서버 구축 및 운영 필요
   - 단일 장애점(Single Point of Failure) 가능성
   - 디버깅 복잡도 증가

3. **추가 인프라**
   - API 서버 하드웨어/클라우드 리소스
   - 모니터링 및 로깅 시스템

4. **연결 공유**
   - 여러 클라이언트가 하나의 연결 공유
   - 한 클라이언트 문제가 전체에 영향 가능 (적절한 처리 필요)

---

## 3. 성능 비교

| 항목 | 직접 연결 | API 서버 |
|------|----------|----------|
| 지연시간 | ~1-5ms | ~10-50ms |
| 처리량 | 높음 | 중간 |
| 연결 수 | 클라이언트 수만큼 | 1개 (공유) |
| CPU 사용 | 클라이언트 분산 | API 서버 집중 |

**참고**: 대부분의 산업용 애플리케이션에서는 10-50ms 지연은 문제없음

---

## 4. 사용 시나리오별 권장사항

### 직접 연결이 적합한 경우
- ✅ 단일 클라이언트 애플리케이션
- ✅ 극도로 낮은 지연시간 요구 (< 1ms)
- ✅ 간단한 구조 선호
- ✅ KepServer와 같은 네트워크

### API 서버가 적합한 경우
- ✅ 여러 클라이언트 (WinForm, Blazor, 모바일)
- ✅ 중앙 관리 필요
- ✅ 보안 강화 필요
- ✅ 확장성 중요
- ✅ 유지보수 용이성 중요

---

## 5. SignalR을 사용하지 않은 이유

### 현재 구현: Server-Sent Events (SSE)

#### SignalR을 사용하지 않은 이유

1. **단순성**
   - SSE는 HTTP 기반 표준 프로토콜
   - 추가 라이브러리 불필요
   - 클라이언트에서 `EventSource` 또는 `HttpClient`만 사용

2. **단방향 통신**
   - 태그 값 변경은 서버 → 클라이언트 단방향
   - 양방향 통신 불필요
   - SSE가 더 적합

3. **HTTP 친화적**
   - 표준 HTTP 프로토콜
   - 방화벽/프록시 통과 용이
   - 웹 표준 준수

4. **리소스 효율성**
   - SignalR은 WebSocket 기반 (오버헤드 있음)
   - SSE는 더 가벼움
   - 단순한 스트리밍에 최적

5. **클라이언트 다양성**
   - SSE는 모든 브라우저 지원
   - WinForm에서도 HttpClient로 구현 가능
   - 추가 NuGet 패키지 불필요

### SignalR이 필요한 경우

SignalR은 다음 경우에 유용:
- 양방향 실시간 통신 필요
- 여러 클라이언트 간 메시징
- 복잡한 이벤트 라우팅
- 그룹 브로드캐스팅

**현재 요구사항**: 태그 값 변경 알림만 필요 → SSE로 충분

---

## 6. 결론

### 현재 방식(API 서버)의 핵심 가치

1. **다중 클라이언트 지원**: WinForm + Blazor 동시 지원
2. **중앙 관리**: 연결, 로깅, 보안 통합 관리
3. **확장성**: 클라이언트 수 증가에 유연하게 대응
4. **유지보수**: 설정 변경 시 API 서버만 수정
5. **표준화**: HTTP 기반 표준 API

### 성능 트레이드오프

- 약간의 지연 증가 (10-50ms) ↔ 확장성 및 관리 용이성
- 대부분의 산업용 애플리케이션에서 허용 가능한 수준

---

## 7. 하이브리드 접근법 (선택사항)

필요시 두 방식을 혼합 사용 가능:

- **실시간 제어**: 직접 연결 (극도로 낮은 지연 필요)
- **모니터링/데이터 수집**: API 서버 (확장성 및 관리)

